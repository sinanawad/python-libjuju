# DO NOT CHANGE THIS FILE! This file is auto-generated by facade.py.
# Changes will be overwritten/lost when the file is regenerated.

from juju.client.facade import Type, ReturnMapping
from juju.client._definitions import *


class AdminFacade(Type):
    name = 'Admin'
    version = 3
    

    @ReturnMapping(LoginResult)
    async def Login(self, auth_tag=None, bakery_version=None, cli_args=None, client_version=None, credentials=None, macaroons=None, nonce=None, token=None, user_data=None):
        '''

        auth_tag : str
        bakery_version : int
        cli_args : str
        client_version : str
        credentials : str
        macaroons : typing.Sequence[~Macaroon]
        nonce : str
        token : str
        user_data : str
        Returns -> LoginResult
        '''
        if auth_tag is not None and not isinstance(auth_tag, (bytes, str)):
            raise Exception("Expected auth_tag to be a str, received: {}".format(type(auth_tag)))

        if bakery_version is not None and not isinstance(bakery_version, int):
            raise Exception("Expected bakery_version to be a int, received: {}".format(type(bakery_version)))

        if cli_args is not None and not isinstance(cli_args, (bytes, str)):
            raise Exception("Expected cli_args to be a str, received: {}".format(type(cli_args)))

        if client_version is not None and not isinstance(client_version, (bytes, str)):
            raise Exception("Expected client_version to be a str, received: {}".format(type(client_version)))

        if credentials is not None and not isinstance(credentials, (bytes, str)):
            raise Exception("Expected credentials to be a str, received: {}".format(type(credentials)))

        if macaroons is not None and not isinstance(macaroons, (bytes, str, list)):
            raise Exception("Expected macaroons to be a Sequence, received: {}".format(type(macaroons)))

        if nonce is not None and not isinstance(nonce, (bytes, str)):
            raise Exception("Expected nonce to be a str, received: {}".format(type(nonce)))

        if token is not None and not isinstance(token, (bytes, str)):
            raise Exception("Expected token to be a str, received: {}".format(type(token)))

        if user_data is not None and not isinstance(user_data, (bytes, str)):
            raise Exception("Expected user_data to be a str, received: {}".format(type(user_data)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Admin',
                   request='Login',
                   version=3,
                   params=_params)
        _params['auth-tag'] = auth_tag
        _params['bakery-version'] = bakery_version
        _params['cli-args'] = cli_args
        _params['client-version'] = client_version
        _params['credentials'] = credentials
        _params['macaroons'] = macaroons
        _params['nonce'] = nonce
        _params['token'] = token
        _params['user-data'] = user_data
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(RedirectInfoResult)
    async def RedirectInfo(self):
        '''

        Returns -> RedirectInfoResult
        '''

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Admin',
                   request='RedirectInfo',
                   version=3,
                   params=_params)

        reply = await self.rpc(msg)
        return reply



class BackupsFacade(Type):
    name = 'Backups'
    version = 3
    

    @ReturnMapping(BackupsMetadataResult)
    async def Create(self, no_download=None, notes=None):
        '''

        no_download : bool
        notes : str
        Returns -> BackupsMetadataResult
        '''
        if no_download is not None and not isinstance(no_download, bool):
            raise Exception("Expected no_download to be a bool, received: {}".format(type(no_download)))

        if notes is not None and not isinstance(notes, (bytes, str)):
            raise Exception("Expected notes to be a str, received: {}".format(type(notes)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Backups',
                   request='Create',
                   version=3,
                   params=_params)
        _params['no-download'] = no_download
        _params['notes'] = notes
        reply = await self.rpc(msg)
        return reply



class HighAvailabilityFacade(Type):
    name = 'HighAvailability'
    version = 3
    

    @ReturnMapping(ControllerDetailsResults)
    async def ControllerDetails(self):
        '''

        Returns -> ControllerDetailsResults
        '''

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='HighAvailability',
                   request='ControllerDetails',
                   version=3,
                   params=_params)

        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ControllersChangeResults)
    async def EnableHA(self, specs=None):
        '''

        specs : typing.Sequence[~ControllersSpec]
        Returns -> ControllersChangeResults
        '''
        if specs is not None and not isinstance(specs, (bytes, str, list)):
            raise Exception("Expected specs to be a Sequence, received: {}".format(type(specs)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='HighAvailability',
                   request='EnableHA',
                   version=3,
                   params=_params)
        _params['specs'] = specs
        reply = await self.rpc(msg)
        return reply



class ResourcesFacade(Type):
    name = 'Resources'
    version = 3
    

    @ReturnMapping(AddPendingResourcesResult)
    async def AddPendingResources(self, entity=None, charm_origin=None, macaroon=None, resources=None, tag=None, url=None):
        '''

        entity : Entity
        charm_origin : CharmOrigin
        macaroon : Macaroon
        resources : typing.Sequence[~CharmResource]
        tag : str
        url : str
        Returns -> AddPendingResourcesResult
        '''
        if entity is not None and not isinstance(entity, (dict, Entity)):
            raise Exception("Expected entity to be a Entity, received: {}".format(type(entity)))

        if charm_origin is not None and not isinstance(charm_origin, (dict, CharmOrigin)):
            raise Exception("Expected charm_origin to be a CharmOrigin, received: {}".format(type(charm_origin)))

        if macaroon is not None and not isinstance(macaroon, (dict, Macaroon)):
            raise Exception("Expected macaroon to be a Macaroon, received: {}".format(type(macaroon)))

        if resources is not None and not isinstance(resources, (bytes, str, list)):
            raise Exception("Expected resources to be a Sequence, received: {}".format(type(resources)))

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception("Expected tag to be a str, received: {}".format(type(tag)))

        if url is not None and not isinstance(url, (bytes, str)):
            raise Exception("Expected url to be a str, received: {}".format(type(url)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Resources',
                   request='AddPendingResources',
                   version=3,
                   params=_params)
        _params['Entity'] = entity
        _params['charm-origin'] = charm_origin
        _params['macaroon'] = macaroon
        _params['resources'] = resources
        _params['tag'] = tag
        _params['url'] = url
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ResourcesResults)
    async def ListResources(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> ResourcesResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Resources',
                   request='ListResources',
                   version=3,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



class UserManagerFacade(Type):
    name = 'UserManager'
    version = 3
    

    @ReturnMapping(AddUserResults)
    async def AddUser(self, users=None):
        '''

        users : typing.Sequence[~AddUser]
        Returns -> AddUserResults
        '''
        if users is not None and not isinstance(users, (bytes, str, list)):
            raise Exception("Expected users to be a Sequence, received: {}".format(type(users)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='UserManager',
                   request='AddUser',
                   version=3,
                   params=_params)
        _params['users'] = users
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def DisableUser(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> ErrorResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='UserManager',
                   request='DisableUser',
                   version=3,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def EnableUser(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> ErrorResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='UserManager',
                   request='EnableUser',
                   version=3,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ModelUserInfoResults)
    async def ModelUserInfo(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> ModelUserInfoResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='UserManager',
                   request='ModelUserInfo',
                   version=3,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def RemoveUser(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> ErrorResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='UserManager',
                   request='RemoveUser',
                   version=3,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(AddUserResults)
    async def ResetPassword(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> AddUserResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='UserManager',
                   request='ResetPassword',
                   version=3,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def SetPassword(self, changes=None):
        '''

        changes : typing.Sequence[~EntityPassword]
        Returns -> ErrorResults
        '''
        if changes is not None and not isinstance(changes, (bytes, str, list)):
            raise Exception("Expected changes to be a Sequence, received: {}".format(type(changes)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='UserManager',
                   request='SetPassword',
                   version=3,
                   params=_params)
        _params['changes'] = changes
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(UserInfoResults)
    async def UserInfo(self, entities=None, include_disabled=None):
        '''

        entities : typing.Sequence[~Entity]
        include_disabled : bool
        Returns -> UserInfoResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        if include_disabled is not None and not isinstance(include_disabled, bool):
            raise Exception("Expected include_disabled to be a bool, received: {}".format(type(include_disabled)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='UserManager',
                   request='UserInfo',
                   version=3,
                   params=_params)
        _params['entities'] = entities
        _params['include-disabled'] = include_disabled
        reply = await self.rpc(msg)
        return reply


