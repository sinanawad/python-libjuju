# DO NOT CHANGE THIS FILE! This file is auto-generated by facade.py.
# Changes will be overwritten/lost when the file is regenerated.

from juju.client.facade import Type, ReturnMapping
from juju.client._definitions import *


class AnnotationsFacade(Type):
    name = 'Annotations'
    version = 2
    

    @ReturnMapping(AnnotationsGetResults)
    async def Get(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> AnnotationsGetResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Annotations',
                   request='Get',
                   version=2,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def Set(self, annotations=None):
        '''

        annotations : typing.Sequence[~EntityAnnotations]
        Returns -> ErrorResults
        '''
        if annotations is not None and not isinstance(annotations, (bytes, str, list)):
            raise Exception("Expected annotations to be a Sequence, received: {}".format(type(annotations)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Annotations',
                   request='Set',
                   version=2,
                   params=_params)
        _params['annotations'] = annotations
        reply = await self.rpc(msg)
        return reply



class BlockFacade(Type):
    name = 'Block'
    version = 2
    

    @ReturnMapping(BlockResults)
    async def List(self):
        '''

        Returns -> BlockResults
        '''

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Block',
                   request='List',
                   version=2,
                   params=_params)

        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResult)
    async def SwitchBlockOff(self, message=None, type_=None):
        '''

        message : str
        type_ : str
        Returns -> ErrorResult
        '''
        if message is not None and not isinstance(message, (bytes, str)):
            raise Exception("Expected message to be a str, received: {}".format(type(message)))

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception("Expected type_ to be a str, received: {}".format(type(type_)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Block',
                   request='SwitchBlockOff',
                   version=2,
                   params=_params)
        _params['message'] = message
        _params['type'] = type_
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResult)
    async def SwitchBlockOn(self, message=None, type_=None):
        '''

        message : str
        type_ : str
        Returns -> ErrorResult
        '''
        if message is not None and not isinstance(message, (bytes, str)):
            raise Exception("Expected message to be a str, received: {}".format(type(message)))

        if type_ is not None and not isinstance(type_, (bytes, str)):
            raise Exception("Expected type_ to be a str, received: {}".format(type(type_)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Block',
                   request='SwitchBlockOn',
                   version=2,
                   params=_params)
        _params['message'] = message
        _params['type'] = type_
        reply = await self.rpc(msg)
        return reply



class SecretsFacade(Type):
    name = 'Secrets'
    version = 2
    

    @ReturnMapping(StringResults)
    async def CreateSecrets(self, args=None):
        '''

        args : typing.Sequence[~CreateSecretArg]
        Returns -> StringResults
        '''
        if args is not None and not isinstance(args, (bytes, str, list)):
            raise Exception("Expected args to be a Sequence, received: {}".format(type(args)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Secrets',
                   request='CreateSecrets',
                   version=2,
                   params=_params)
        _params['args'] = args
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def GrantSecret(self, applications=None, label=None, uri=None):
        '''

        applications : typing.Sequence[str]
        label : str
        uri : str
        Returns -> ErrorResults
        '''
        if applications is not None and not isinstance(applications, (bytes, str, list)):
            raise Exception("Expected applications to be a Sequence, received: {}".format(type(applications)))

        if label is not None and not isinstance(label, (bytes, str)):
            raise Exception("Expected label to be a str, received: {}".format(type(label)))

        if uri is not None and not isinstance(uri, (bytes, str)):
            raise Exception("Expected uri to be a str, received: {}".format(type(uri)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Secrets',
                   request='GrantSecret',
                   version=2,
                   params=_params)
        _params['applications'] = applications
        _params['label'] = label
        _params['uri'] = uri
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ListSecretResults)
    async def ListSecrets(self, filter_=None, show_secrets=None):
        '''

        filter_ : SecretsFilter
        show_secrets : bool
        Returns -> ListSecretResults
        '''
        if filter_ is not None and not isinstance(filter_, (dict, SecretsFilter)):
            raise Exception("Expected filter_ to be a SecretsFilter, received: {}".format(type(filter_)))

        if show_secrets is not None and not isinstance(show_secrets, bool):
            raise Exception("Expected show_secrets to be a bool, received: {}".format(type(show_secrets)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Secrets',
                   request='ListSecrets',
                   version=2,
                   params=_params)
        _params['filter'] = filter_
        _params['show-secrets'] = show_secrets
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def RemoveSecrets(self, args=None):
        '''

        args : typing.Sequence[~DeleteSecretArg]
        Returns -> ErrorResults
        '''
        if args is not None and not isinstance(args, (bytes, str, list)):
            raise Exception("Expected args to be a Sequence, received: {}".format(type(args)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Secrets',
                   request='RemoveSecrets',
                   version=2,
                   params=_params)
        _params['args'] = args
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def RevokeSecret(self, applications=None, label=None, uri=None):
        '''

        applications : typing.Sequence[str]
        label : str
        uri : str
        Returns -> ErrorResults
        '''
        if applications is not None and not isinstance(applications, (bytes, str, list)):
            raise Exception("Expected applications to be a Sequence, received: {}".format(type(applications)))

        if label is not None and not isinstance(label, (bytes, str)):
            raise Exception("Expected label to be a str, received: {}".format(type(label)))

        if uri is not None and not isinstance(uri, (bytes, str)):
            raise Exception("Expected uri to be a str, received: {}".format(type(uri)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Secrets',
                   request='RevokeSecret',
                   version=2,
                   params=_params)
        _params['applications'] = applications
        _params['label'] = label
        _params['uri'] = uri
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def UpdateSecrets(self, args=None):
        '''

        args : typing.Sequence[~UpdateUserSecretArg]
        Returns -> ErrorResults
        '''
        if args is not None and not isinstance(args, (bytes, str, list)):
            raise Exception("Expected args to be a Sequence, received: {}".format(type(args)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Secrets',
                   request='UpdateSecrets',
                   version=2,
                   params=_params)
        _params['args'] = args
        reply = await self.rpc(msg)
        return reply


