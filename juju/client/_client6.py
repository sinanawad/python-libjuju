# DO NOT CHANGE THIS FILE! This file is auto-generated by facade.py.
# Changes will be overwritten/lost when the file is regenerated.

from juju.client.facade import Type, ReturnMapping
from juju.client._definitions import *


class ApplicationOffersFacade(Type):
    name = 'ApplicationOffers'
    version = 6
    

    @ReturnMapping(ApplicationOffersResults)
    async def ApplicationOffers(self, bakery_version=None, offer_urls=None):
        '''

        bakery_version : int
        offer_urls : typing.Sequence[str]
        Returns -> ApplicationOffersResults
        '''
        if bakery_version is not None and not isinstance(bakery_version, int):
            raise Exception("Expected bakery_version to be a int, received: {}".format(type(bakery_version)))

        if offer_urls is not None and not isinstance(offer_urls, (bytes, str, list)):
            raise Exception("Expected offer_urls to be a Sequence, received: {}".format(type(offer_urls)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ApplicationOffers',
                   request='ApplicationOffers',
                   version=6,
                   params=_params)
        _params['bakery-version'] = bakery_version
        _params['offer-urls'] = offer_urls
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def DestroyOffers(self, force=None, offer_urls=None):
        '''

        force : bool
        offer_urls : typing.Sequence[str]
        Returns -> ErrorResults
        '''
        if force is not None and not isinstance(force, bool):
            raise Exception("Expected force to be a bool, received: {}".format(type(force)))

        if offer_urls is not None and not isinstance(offer_urls, (bytes, str, list)):
            raise Exception("Expected offer_urls to be a Sequence, received: {}".format(type(offer_urls)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ApplicationOffers',
                   request='DestroyOffers',
                   version=6,
                   params=_params)
        _params['force'] = force
        _params['offer-urls'] = offer_urls
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(QueryApplicationOffersResultsV5)
    async def FindApplicationOffers(self, filters=None):
        '''

        filters : typing.Sequence[~OfferFilter]
        Returns -> QueryApplicationOffersResultsV5
        '''
        if filters is not None and not isinstance(filters, (bytes, str, list)):
            raise Exception("Expected filters to be a Sequence, received: {}".format(type(filters)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ApplicationOffers',
                   request='FindApplicationOffers',
                   version=6,
                   params=_params)
        _params['Filters'] = filters
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ConsumeOfferDetailsResults)
    async def GetConsumeDetails(self, offer_urls=None, user_tag=None):
        '''

        offer_urls : OfferURLs
        user_tag : str
        Returns -> ConsumeOfferDetailsResults
        '''
        if offer_urls is not None and not isinstance(offer_urls, (dict, OfferURLs)):
            raise Exception("Expected offer_urls to be a OfferURLs, received: {}".format(type(offer_urls)))

        if user_tag is not None and not isinstance(user_tag, (bytes, str)):
            raise Exception("Expected user_tag to be a str, received: {}".format(type(user_tag)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ApplicationOffers',
                   request='GetConsumeDetails',
                   version=6,
                   params=_params)
        _params['offer-urls'] = offer_urls
        _params['user-tag'] = user_tag
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(QueryApplicationOffersResultsV5)
    async def ListApplicationOffers(self, filters=None):
        '''

        filters : typing.Sequence[~OfferFilter]
        Returns -> QueryApplicationOffersResultsV5
        '''
        if filters is not None and not isinstance(filters, (bytes, str, list)):
            raise Exception("Expected filters to be a Sequence, received: {}".format(type(filters)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ApplicationOffers',
                   request='ListApplicationOffers',
                   version=6,
                   params=_params)
        _params['Filters'] = filters
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def ModifyOfferAccess(self, changes=None):
        '''

        changes : typing.Sequence[~ModifyOfferAccess]
        Returns -> ErrorResults
        '''
        if changes is not None and not isinstance(changes, (bytes, str, list)):
            raise Exception("Expected changes to be a Sequence, received: {}".format(type(changes)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ApplicationOffers',
                   request='ModifyOfferAccess',
                   version=6,
                   params=_params)
        _params['changes'] = changes
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def Offer(self, offers=None):
        '''

        offers : typing.Sequence[~AddApplicationOffer]
        Returns -> ErrorResults
        '''
        if offers is not None and not isinstance(offers, (bytes, str, list)):
            raise Exception("Expected offers to be a Sequence, received: {}".format(type(offers)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ApplicationOffers',
                   request='Offer',
                   version=6,
                   params=_params)
        _params['Offers'] = offers
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(RemoteApplicationInfoResults)
    async def RemoteApplicationInfo(self, bakery_version=None, offer_urls=None):
        '''

        bakery_version : int
        offer_urls : typing.Sequence[str]
        Returns -> RemoteApplicationInfoResults
        '''
        if bakery_version is not None and not isinstance(bakery_version, int):
            raise Exception("Expected bakery_version to be a int, received: {}".format(type(bakery_version)))

        if offer_urls is not None and not isinstance(offer_urls, (bytes, str, list)):
            raise Exception("Expected offer_urls to be a Sequence, received: {}".format(type(offer_urls)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ApplicationOffers',
                   request='RemoteApplicationInfo',
                   version=6,
                   params=_params)
        _params['bakery-version'] = bakery_version
        _params['offer-urls'] = offer_urls
        reply = await self.rpc(msg)
        return reply



class SpacesFacade(Type):
    name = 'Spaces'
    version = 6
    

    @ReturnMapping(ErrorResults)
    async def CreateSpaces(self, spaces=None):
        '''

        spaces : typing.Sequence[~CreateSpaceParams]
        Returns -> ErrorResults
        '''
        if spaces is not None and not isinstance(spaces, (bytes, str, list)):
            raise Exception("Expected spaces to be a Sequence, received: {}".format(type(spaces)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Spaces',
                   request='CreateSpaces',
                   version=6,
                   params=_params)
        _params['spaces'] = spaces
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ListSpacesResults)
    async def ListSpaces(self):
        '''

        Returns -> ListSpacesResults
        '''

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Spaces',
                   request='ListSpaces',
                   version=6,
                   params=_params)

        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(MoveSubnetsResults)
    async def MoveSubnets(self, args=None):
        '''

        args : typing.Sequence[~MoveSubnetsParam]
        Returns -> MoveSubnetsResults
        '''
        if args is not None and not isinstance(args, (bytes, str, list)):
            raise Exception("Expected args to be a Sequence, received: {}".format(type(args)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Spaces',
                   request='MoveSubnets',
                   version=6,
                   params=_params)
        _params['args'] = args
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(None)
    async def ReloadSpaces(self):
        '''

        Returns -> None
        '''

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Spaces',
                   request='ReloadSpaces',
                   version=6,
                   params=_params)

        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(RemoveSpaceResults)
    async def RemoveSpace(self, space_param=None):
        '''

        space_param : typing.Sequence[~RemoveSpaceParam]
        Returns -> RemoveSpaceResults
        '''
        if space_param is not None and not isinstance(space_param, (bytes, str, list)):
            raise Exception("Expected space_param to be a Sequence, received: {}".format(type(space_param)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Spaces',
                   request='RemoveSpace',
                   version=6,
                   params=_params)
        _params['space-param'] = space_param
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def RenameSpace(self, changes=None):
        '''

        changes : typing.Sequence[~RenameSpaceParams]
        Returns -> ErrorResults
        '''
        if changes is not None and not isinstance(changes, (bytes, str, list)):
            raise Exception("Expected changes to be a Sequence, received: {}".format(type(changes)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Spaces',
                   request='RenameSpace',
                   version=6,
                   params=_params)
        _params['changes'] = changes
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ShowSpaceResults)
    async def ShowSpace(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> ShowSpaceResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Spaces',
                   request='ShowSpace',
                   version=6,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply


