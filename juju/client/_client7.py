# DO NOT CHANGE THIS FILE! This file is auto-generated by facade.py.
# Changes will be overwritten/lost when the file is regenerated.

from juju.client.facade import Type, ReturnMapping
from juju.client._definitions import *


class ActionFacade(Type):
    name = 'Action'
    version = 7
    

    @ReturnMapping(ActionResults)
    async def Actions(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> ActionResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Action',
                   request='Actions',
                   version=7,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ApplicationsCharmActionsResults)
    async def ApplicationsCharmsActions(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> ApplicationsCharmActionsResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Action',
                   request='ApplicationsCharmsActions',
                   version=7,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ActionResults)
    async def Cancel(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> ActionResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Action',
                   request='Cancel',
                   version=7,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(EnqueuedActions)
    async def EnqueueOperation(self, actions=None):
        '''

        actions : typing.Sequence[~Action]
        Returns -> EnqueuedActions
        '''
        if actions is not None and not isinstance(actions, (bytes, str, list)):
            raise Exception("Expected actions to be a Sequence, received: {}".format(type(actions)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Action',
                   request='EnqueueOperation',
                   version=7,
                   params=_params)
        _params['actions'] = actions
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(OperationResults)
    async def ListOperations(self, actions=None, applications=None, limit=None, machines=None, offset=None, status=None, units=None):
        '''

        actions : typing.Sequence[str]
        applications : typing.Sequence[str]
        limit : int
        machines : typing.Sequence[str]
        offset : int
        status : typing.Sequence[str]
        units : typing.Sequence[str]
        Returns -> OperationResults
        '''
        if actions is not None and not isinstance(actions, (bytes, str, list)):
            raise Exception("Expected actions to be a Sequence, received: {}".format(type(actions)))

        if applications is not None and not isinstance(applications, (bytes, str, list)):
            raise Exception("Expected applications to be a Sequence, received: {}".format(type(applications)))

        if limit is not None and not isinstance(limit, int):
            raise Exception("Expected limit to be a int, received: {}".format(type(limit)))

        if machines is not None and not isinstance(machines, (bytes, str, list)):
            raise Exception("Expected machines to be a Sequence, received: {}".format(type(machines)))

        if offset is not None and not isinstance(offset, int):
            raise Exception("Expected offset to be a int, received: {}".format(type(offset)))

        if status is not None and not isinstance(status, (bytes, str, list)):
            raise Exception("Expected status to be a Sequence, received: {}".format(type(status)))

        if units is not None and not isinstance(units, (bytes, str, list)):
            raise Exception("Expected units to be a Sequence, received: {}".format(type(units)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Action',
                   request='ListOperations',
                   version=7,
                   params=_params)
        _params['actions'] = actions
        _params['applications'] = applications
        _params['limit'] = limit
        _params['machines'] = machines
        _params['offset'] = offset
        _params['status'] = status
        _params['units'] = units
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(OperationResults)
    async def Operations(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> OperationResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Action',
                   request='Operations',
                   version=7,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(EnqueuedActions)
    async def Run(self, applications=None, commands=None, execution_group=None, machines=None, parallel=None, timeout=None, units=None):
        '''

        applications : typing.Sequence[str]
        commands : str
        execution_group : str
        machines : typing.Sequence[str]
        parallel : bool
        timeout : int
        units : typing.Sequence[str]
        Returns -> EnqueuedActions
        '''
        if applications is not None and not isinstance(applications, (bytes, str, list)):
            raise Exception("Expected applications to be a Sequence, received: {}".format(type(applications)))

        if commands is not None and not isinstance(commands, (bytes, str)):
            raise Exception("Expected commands to be a str, received: {}".format(type(commands)))

        if execution_group is not None and not isinstance(execution_group, (bytes, str)):
            raise Exception("Expected execution_group to be a str, received: {}".format(type(execution_group)))

        if machines is not None and not isinstance(machines, (bytes, str, list)):
            raise Exception("Expected machines to be a Sequence, received: {}".format(type(machines)))

        if parallel is not None and not isinstance(parallel, bool):
            raise Exception("Expected parallel to be a bool, received: {}".format(type(parallel)))

        if timeout is not None and not isinstance(timeout, int):
            raise Exception("Expected timeout to be a int, received: {}".format(type(timeout)))

        if units is not None and not isinstance(units, (bytes, str, list)):
            raise Exception("Expected units to be a Sequence, received: {}".format(type(units)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Action',
                   request='Run',
                   version=7,
                   params=_params)
        _params['applications'] = applications
        _params['commands'] = commands
        _params['execution-group'] = execution_group
        _params['machines'] = machines
        _params['parallel'] = parallel
        _params['timeout'] = timeout
        _params['units'] = units
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(EnqueuedActions)
    async def RunOnAllMachines(self, applications=None, commands=None, execution_group=None, machines=None, parallel=None, timeout=None, units=None):
        '''

        applications : typing.Sequence[str]
        commands : str
        execution_group : str
        machines : typing.Sequence[str]
        parallel : bool
        timeout : int
        units : typing.Sequence[str]
        Returns -> EnqueuedActions
        '''
        if applications is not None and not isinstance(applications, (bytes, str, list)):
            raise Exception("Expected applications to be a Sequence, received: {}".format(type(applications)))

        if commands is not None and not isinstance(commands, (bytes, str)):
            raise Exception("Expected commands to be a str, received: {}".format(type(commands)))

        if execution_group is not None and not isinstance(execution_group, (bytes, str)):
            raise Exception("Expected execution_group to be a str, received: {}".format(type(execution_group)))

        if machines is not None and not isinstance(machines, (bytes, str, list)):
            raise Exception("Expected machines to be a Sequence, received: {}".format(type(machines)))

        if parallel is not None and not isinstance(parallel, bool):
            raise Exception("Expected parallel to be a bool, received: {}".format(type(parallel)))

        if timeout is not None and not isinstance(timeout, int):
            raise Exception("Expected timeout to be a int, received: {}".format(type(timeout)))

        if units is not None and not isinstance(units, (bytes, str, list)):
            raise Exception("Expected units to be a Sequence, received: {}".format(type(units)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Action',
                   request='RunOnAllMachines',
                   version=7,
                   params=_params)
        _params['applications'] = applications
        _params['commands'] = commands
        _params['execution-group'] = execution_group
        _params['machines'] = machines
        _params['parallel'] = parallel
        _params['timeout'] = timeout
        _params['units'] = units
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(StringsWatchResults)
    async def WatchActionsProgress(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> StringsWatchResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Action',
                   request='WatchActionsProgress',
                   version=7,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



class CharmsFacade(Type):
    name = 'Charms'
    version = 7
    

    @ReturnMapping(CharmOriginResult)
    async def AddCharm(self, charm_origin=None, force=None, url=None):
        '''

        charm_origin : CharmOrigin
        force : bool
        url : str
        Returns -> CharmOriginResult
        '''
        if charm_origin is not None and not isinstance(charm_origin, (dict, CharmOrigin)):
            raise Exception("Expected charm_origin to be a CharmOrigin, received: {}".format(type(charm_origin)))

        if force is not None and not isinstance(force, bool):
            raise Exception("Expected force to be a bool, received: {}".format(type(force)))

        if url is not None and not isinstance(url, (bytes, str)):
            raise Exception("Expected url to be a str, received: {}".format(type(url)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Charms',
                   request='AddCharm',
                   version=7,
                   params=_params)
        _params['charm-origin'] = charm_origin
        _params['force'] = force
        _params['url'] = url
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(Charm)
    async def CharmInfo(self, url=None):
        '''

        url : str
        Returns -> Charm
        '''
        if url is not None and not isinstance(url, (bytes, str)):
            raise Exception("Expected url to be a str, received: {}".format(type(url)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Charms',
                   request='CharmInfo',
                   version=7,
                   params=_params)
        _params['url'] = url
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def CheckCharmPlacement(self, placements=None):
        '''

        placements : typing.Sequence[~ApplicationCharmPlacement]
        Returns -> ErrorResults
        '''
        if placements is not None and not isinstance(placements, (bytes, str, list)):
            raise Exception("Expected placements to be a Sequence, received: {}".format(type(placements)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Charms',
                   request='CheckCharmPlacement',
                   version=7,
                   params=_params)
        _params['placements'] = placements
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(DownloadInfoResults)
    async def GetDownloadInfos(self, entities=None):
        '''

        entities : typing.Sequence[~CharmURLAndOrigin]
        Returns -> DownloadInfoResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Charms',
                   request='GetDownloadInfos',
                   version=7,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(CharmsListResult)
    async def List(self, names=None):
        '''

        names : typing.Sequence[str]
        Returns -> CharmsListResult
        '''
        if names is not None and not isinstance(names, (bytes, str, list)):
            raise Exception("Expected names to be a Sequence, received: {}".format(type(names)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Charms',
                   request='List',
                   version=7,
                   params=_params)
        _params['names'] = names
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(CharmResourcesResults)
    async def ListCharmResources(self, entities=None):
        '''

        entities : typing.Sequence[~CharmURLAndOrigin]
        Returns -> CharmResourcesResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Charms',
                   request='ListCharmResources',
                   version=7,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ResolveCharmWithChannelResults)
    async def ResolveCharms(self, macaroon=None, resolve=None):
        '''

        macaroon : Macaroon
        resolve : typing.Sequence[~ResolveCharmWithChannel]
        Returns -> ResolveCharmWithChannelResults
        '''
        if macaroon is not None and not isinstance(macaroon, (dict, Macaroon)):
            raise Exception("Expected macaroon to be a Macaroon, received: {}".format(type(macaroon)))

        if resolve is not None and not isinstance(resolve, (bytes, str, list)):
            raise Exception("Expected resolve to be a Sequence, received: {}".format(type(resolve)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Charms',
                   request='ResolveCharms',
                   version=7,
                   params=_params)
        _params['macaroon'] = macaroon
        _params['resolve'] = resolve
        reply = await self.rpc(msg)
        return reply



class CloudFacade(Type):
    name = 'Cloud'
    version = 7
    

    @ReturnMapping(None)
    async def AddCloud(self, cloud=None, force=None, name=None):
        '''

        cloud : Cloud
        force : bool
        name : str
        Returns -> None
        '''
        if cloud is not None and not isinstance(cloud, (dict, Cloud)):
            raise Exception("Expected cloud to be a Cloud, received: {}".format(type(cloud)))

        if force is not None and not isinstance(force, bool):
            raise Exception("Expected force to be a bool, received: {}".format(type(force)))

        if name is not None and not isinstance(name, (bytes, str)):
            raise Exception("Expected name to be a str, received: {}".format(type(name)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Cloud',
                   request='AddCloud',
                   version=7,
                   params=_params)
        _params['cloud'] = cloud
        _params['force'] = force
        _params['name'] = name
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def AddCredentials(self, credentials=None):
        '''

        credentials : typing.Sequence[~TaggedCredential]
        Returns -> ErrorResults
        '''
        if credentials is not None and not isinstance(credentials, (bytes, str, list)):
            raise Exception("Expected credentials to be a Sequence, received: {}".format(type(credentials)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Cloud',
                   request='AddCredentials',
                   version=7,
                   params=_params)
        _params['credentials'] = credentials
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(CloudResults)
    async def Cloud(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> CloudResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Cloud',
                   request='Cloud',
                   version=7,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(CloudInfoResults)
    async def CloudInfo(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> CloudInfoResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Cloud',
                   request='CloudInfo',
                   version=7,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(CloudsResult)
    async def Clouds(self):
        '''

        Returns -> CloudsResult
        '''

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Cloud',
                   request='Clouds',
                   version=7,
                   params=_params)

        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(CloudCredentialResults)
    async def Credential(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> CloudCredentialResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Cloud',
                   request='Credential',
                   version=7,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(CredentialContentResults)
    async def CredentialContents(self, credentials=None, include_secrets=None):
        '''

        credentials : typing.Sequence[~CloudCredentialArg]
        include_secrets : bool
        Returns -> CredentialContentResults
        '''
        if credentials is not None and not isinstance(credentials, (bytes, str, list)):
            raise Exception("Expected credentials to be a Sequence, received: {}".format(type(credentials)))

        if include_secrets is not None and not isinstance(include_secrets, bool):
            raise Exception("Expected include_secrets to be a bool, received: {}".format(type(include_secrets)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Cloud',
                   request='CredentialContents',
                   version=7,
                   params=_params)
        _params['credentials'] = credentials
        _params['include-secrets'] = include_secrets
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ListCloudInfoResults)
    async def ListCloudInfo(self, all_=None, user_tag=None):
        '''

        all_ : bool
        user_tag : str
        Returns -> ListCloudInfoResults
        '''
        if all_ is not None and not isinstance(all_, bool):
            raise Exception("Expected all_ to be a bool, received: {}".format(type(all_)))

        if user_tag is not None and not isinstance(user_tag, (bytes, str)):
            raise Exception("Expected user_tag to be a str, received: {}".format(type(user_tag)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Cloud',
                   request='ListCloudInfo',
                   version=7,
                   params=_params)
        _params['all'] = all_
        _params['user-tag'] = user_tag
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def ModifyCloudAccess(self, changes=None):
        '''

        changes : typing.Sequence[~ModifyCloudAccess]
        Returns -> ErrorResults
        '''
        if changes is not None and not isinstance(changes, (bytes, str, list)):
            raise Exception("Expected changes to be a Sequence, received: {}".format(type(changes)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Cloud',
                   request='ModifyCloudAccess',
                   version=7,
                   params=_params)
        _params['changes'] = changes
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def RemoveClouds(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> ErrorResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Cloud',
                   request='RemoveClouds',
                   version=7,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def RevokeCredentialsCheckModels(self, credentials=None):
        '''

        credentials : typing.Sequence[~RevokeCredentialArg]
        Returns -> ErrorResults
        '''
        if credentials is not None and not isinstance(credentials, (bytes, str, list)):
            raise Exception("Expected credentials to be a Sequence, received: {}".format(type(credentials)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Cloud',
                   request='RevokeCredentialsCheckModels',
                   version=7,
                   params=_params)
        _params['credentials'] = credentials
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def UpdateCloud(self, clouds=None):
        '''

        clouds : typing.Sequence[~AddCloudArgs]
        Returns -> ErrorResults
        '''
        if clouds is not None and not isinstance(clouds, (bytes, str, list)):
            raise Exception("Expected clouds to be a Sequence, received: {}".format(type(clouds)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Cloud',
                   request='UpdateCloud',
                   version=7,
                   params=_params)
        _params['clouds'] = clouds
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(UpdateCredentialResults)
    async def UpdateCredentialsCheckModels(self, credentials=None, force=None):
        '''

        credentials : typing.Sequence[~TaggedCredential]
        force : bool
        Returns -> UpdateCredentialResults
        '''
        if credentials is not None and not isinstance(credentials, (bytes, str, list)):
            raise Exception("Expected credentials to be a Sequence, received: {}".format(type(credentials)))

        if force is not None and not isinstance(force, bool):
            raise Exception("Expected force to be a bool, received: {}".format(type(force)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Cloud',
                   request='UpdateCredentialsCheckModels',
                   version=7,
                   params=_params)
        _params['credentials'] = credentials
        _params['force'] = force
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(StringsResults)
    async def UserCredentials(self, user_clouds=None):
        '''

        user_clouds : typing.Sequence[~UserCloud]
        Returns -> StringsResults
        '''
        if user_clouds is not None and not isinstance(user_clouds, (bytes, str, list)):
            raise Exception("Expected user_clouds to be a Sequence, received: {}".format(type(user_clouds)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Cloud',
                   request='UserCredentials',
                   version=7,
                   params=_params)
        _params['user-clouds'] = user_clouds
        reply = await self.rpc(msg)
        return reply



class StorageFacade(Type):
    name = 'Storage'
    version = 7
    

    @ReturnMapping(AddStorageResults)
    async def AddToUnit(self, storages=None):
        '''

        storages : typing.Sequence[~StorageAddParams]
        Returns -> AddStorageResults
        '''
        if storages is not None and not isinstance(storages, (bytes, str, list)):
            raise Exception("Expected storages to be a Sequence, received: {}".format(type(storages)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Storage',
                   request='AddToUnit',
                   version=7,
                   params=_params)
        _params['storages'] = storages
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def Attach(self, ids=None):
        '''

        ids : typing.Sequence[~StorageAttachmentId]
        Returns -> ErrorResults
        '''
        if ids is not None and not isinstance(ids, (bytes, str, list)):
            raise Exception("Expected ids to be a Sequence, received: {}".format(type(ids)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Storage',
                   request='Attach',
                   version=7,
                   params=_params)
        _params['ids'] = ids
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def CreatePool(self, pools=None):
        '''

        pools : typing.Sequence[~StoragePool]
        Returns -> ErrorResults
        '''
        if pools is not None and not isinstance(pools, (bytes, str, list)):
            raise Exception("Expected pools to be a Sequence, received: {}".format(type(pools)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Storage',
                   request='CreatePool',
                   version=7,
                   params=_params)
        _params['pools'] = pools
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def DetachStorage(self, force=None, ids=None, max_wait=None):
        '''

        force : bool
        ids : StorageAttachmentIds
        max_wait : int
        Returns -> ErrorResults
        '''
        if force is not None and not isinstance(force, bool):
            raise Exception("Expected force to be a bool, received: {}".format(type(force)))

        if ids is not None and not isinstance(ids, (dict, StorageAttachmentIds)):
            raise Exception("Expected ids to be a StorageAttachmentIds, received: {}".format(type(ids)))

        if max_wait is not None and not isinstance(max_wait, int):
            raise Exception("Expected max_wait to be a int, received: {}".format(type(max_wait)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Storage',
                   request='DetachStorage',
                   version=7,
                   params=_params)
        _params['force'] = force
        _params['ids'] = ids
        _params['max-wait'] = max_wait
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ImportStorageResults)
    async def Import(self, storage=None):
        '''

        storage : typing.Sequence[~ImportStorageParamsV2]
        Returns -> ImportStorageResults
        '''
        if storage is not None and not isinstance(storage, (bytes, str, list)):
            raise Exception("Expected storage to be a Sequence, received: {}".format(type(storage)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Storage',
                   request='Import',
                   version=7,
                   params=_params)
        _params['storage'] = storage
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(FilesystemDetailsListResults)
    async def ListFilesystems(self, filters=None):
        '''

        filters : typing.Sequence[~FilesystemFilter]
        Returns -> FilesystemDetailsListResults
        '''
        if filters is not None and not isinstance(filters, (bytes, str, list)):
            raise Exception("Expected filters to be a Sequence, received: {}".format(type(filters)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Storage',
                   request='ListFilesystems',
                   version=7,
                   params=_params)
        _params['filters'] = filters
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(StoragePoolsResults)
    async def ListPools(self, filters=None):
        '''

        filters : typing.Sequence[~StoragePoolFilter]
        Returns -> StoragePoolsResults
        '''
        if filters is not None and not isinstance(filters, (bytes, str, list)):
            raise Exception("Expected filters to be a Sequence, received: {}".format(type(filters)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Storage',
                   request='ListPools',
                   version=7,
                   params=_params)
        _params['filters'] = filters
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(StorageDetailsListResults)
    async def ListStorageDetails(self, filters=None):
        '''

        filters : typing.Sequence[~StorageFilter]
        Returns -> StorageDetailsListResults
        '''
        if filters is not None and not isinstance(filters, (bytes, str, list)):
            raise Exception("Expected filters to be a Sequence, received: {}".format(type(filters)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Storage',
                   request='ListStorageDetails',
                   version=7,
                   params=_params)
        _params['filters'] = filters
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(VolumeDetailsListResults)
    async def ListVolumes(self, filters=None):
        '''

        filters : typing.Sequence[~VolumeFilter]
        Returns -> VolumeDetailsListResults
        '''
        if filters is not None and not isinstance(filters, (bytes, str, list)):
            raise Exception("Expected filters to be a Sequence, received: {}".format(type(filters)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Storage',
                   request='ListVolumes',
                   version=7,
                   params=_params)
        _params['filters'] = filters
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def Remove(self, storage=None):
        '''

        storage : typing.Sequence[~RemoveStorageInstance]
        Returns -> ErrorResults
        '''
        if storage is not None and not isinstance(storage, (bytes, str, list)):
            raise Exception("Expected storage to be a Sequence, received: {}".format(type(storage)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Storage',
                   request='Remove',
                   version=7,
                   params=_params)
        _params['storage'] = storage
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def RemovePool(self, pools=None):
        '''

        pools : typing.Sequence[~StoragePoolDeleteArg]
        Returns -> ErrorResults
        '''
        if pools is not None and not isinstance(pools, (bytes, str, list)):
            raise Exception("Expected pools to be a Sequence, received: {}".format(type(pools)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Storage',
                   request='RemovePool',
                   version=7,
                   params=_params)
        _params['pools'] = pools
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(StorageDetailsResults)
    async def StorageDetails(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> StorageDetailsResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Storage',
                   request='StorageDetails',
                   version=7,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def UpdatePool(self, pools=None):
        '''

        pools : typing.Sequence[~StoragePool]
        Returns -> ErrorResults
        '''
        if pools is not None and not isinstance(pools, (bytes, str, list)):
            raise Exception("Expected pools to be a Sequence, received: {}".format(type(pools)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Storage',
                   request='UpdatePool',
                   version=7,
                   params=_params)
        _params['pools'] = pools
        reply = await self.rpc(msg)
        return reply


