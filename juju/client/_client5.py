# DO NOT CHANGE THIS FILE! This file is auto-generated by facade.py.
# Changes will be overwritten/lost when the file is regenerated.

from juju.client.facade import Type, ReturnMapping
from juju.client._definitions import *


class SSHClientFacade(Type):
    name = 'SSHClient'
    version = 5
    

    @ReturnMapping(SSHAddressesResults)
    async def AllAddresses(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> SSHAddressesResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='SSHClient',
                   request='AllAddresses',
                   version=5,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(CloudSpecResult)
    async def ModelCredentialForSSH(self):
        '''

        Returns -> CloudSpecResult
        '''

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='SSHClient',
                   request='ModelCredentialForSSH',
                   version=5,
                   params=_params)

        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(SSHAddressResults)
    async def PrivateAddress(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> SSHAddressResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='SSHClient',
                   request='PrivateAddress',
                   version=5,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(SSHProxyResult)
    async def Proxy(self):
        '''

        Returns -> SSHProxyResult
        '''

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='SSHClient',
                   request='Proxy',
                   version=5,
                   params=_params)

        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(SSHAddressResults)
    async def PublicAddress(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> SSHAddressResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='SSHClient',
                   request='PublicAddress',
                   version=5,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(SSHPublicKeysResults)
    async def PublicKeys(self, entities=None):
        '''

        entities : typing.Sequence[~Entity]
        Returns -> SSHPublicKeysResults
        '''
        if entities is not None and not isinstance(entities, (bytes, str, list)):
            raise Exception("Expected entities to be a Sequence, received: {}".format(type(entities)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='SSHClient',
                   request='PublicKeys',
                   version=5,
                   params=_params)
        _params['entities'] = entities
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(SSHAddressResult)
    async def VirtualHostname(self, container=None, tag=None):
        '''

        container : str
        tag : str
        Returns -> SSHAddressResult
        '''
        if container is not None and not isinstance(container, (bytes, str)):
            raise Exception("Expected container to be a str, received: {}".format(type(container)))

        if tag is not None and not isinstance(tag, (bytes, str)):
            raise Exception("Expected tag to be a str, received: {}".format(type(tag)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='SSHClient',
                   request='VirtualHostname',
                   version=5,
                   params=_params)
        _params['container'] = container
        _params['tag'] = tag
        reply = await self.rpc(msg)
        return reply



class SubnetsFacade(Type):
    name = 'Subnets'
    version = 5
    

    @ReturnMapping(ZoneResults)
    async def AllZones(self):
        '''

        Returns -> ZoneResults
        '''

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Subnets',
                   request='AllZones',
                   version=5,
                   params=_params)

        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ListSubnetsResults)
    async def ListSubnets(self, space_tag=None, zone=None):
        '''

        space_tag : str
        zone : str
        Returns -> ListSubnetsResults
        '''
        if space_tag is not None and not isinstance(space_tag, (bytes, str)):
            raise Exception("Expected space_tag to be a str, received: {}".format(type(space_tag)))

        if zone is not None and not isinstance(zone, (bytes, str)):
            raise Exception("Expected zone to be a str, received: {}".format(type(zone)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Subnets',
                   request='ListSubnets',
                   version=5,
                   params=_params)
        _params['space-tag'] = space_tag
        _params['zone'] = zone
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(SubnetsResults)
    async def SubnetsByCIDR(self, cidrs=None):
        '''

        cidrs : typing.Sequence[str]
        Returns -> SubnetsResults
        '''
        if cidrs is not None and not isinstance(cidrs, (bytes, str, list)):
            raise Exception("Expected cidrs to be a Sequence, received: {}".format(type(cidrs)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Subnets',
                   request='SubnetsByCIDR',
                   version=5,
                   params=_params)
        _params['cidrs'] = cidrs
        reply = await self.rpc(msg)
        return reply


