# DO NOT CHANGE THIS FILE! This file is auto-generated by facade.py.
# Changes will be overwritten/lost when the file is regenerated.

from juju.client.facade import Type, ReturnMapping
from juju.client._definitions import *


class ModelConfigFacade(Type):
    name = 'ModelConfig'
    version = 4
    

    @ReturnMapping(GetConstraintsResults)
    async def GetModelConstraints(self):
        '''

        Returns -> GetConstraintsResults
        '''

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ModelConfig',
                   request='GetModelConstraints',
                   version=4,
                   params=_params)

        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(StringResult)
    async def GetModelSecretBackend(self):
        '''

        Returns -> StringResult
        '''

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ModelConfig',
                   request='GetModelSecretBackend',
                   version=4,
                   params=_params)

        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ModelConfigResults)
    async def ModelGet(self):
        '''

        Returns -> ModelConfigResults
        '''

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ModelConfig',
                   request='ModelGet',
                   version=4,
                   params=_params)

        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(None)
    async def ModelSet(self, config=None):
        '''

        config : typing.Mapping[str, typing.Any]
        Returns -> None
        '''
        if config is not None and not isinstance(config, dict):
            raise Exception("Expected config to be a Mapping, received: {}".format(type(config)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ModelConfig',
                   request='ModelSet',
                   version=4,
                   params=_params)
        _params['config'] = config
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(None)
    async def ModelUnset(self, keys=None):
        '''

        keys : typing.Sequence[str]
        Returns -> None
        '''
        if keys is not None and not isinstance(keys, (bytes, str, list)):
            raise Exception("Expected keys to be a Sequence, received: {}".format(type(keys)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ModelConfig',
                   request='ModelUnset',
                   version=4,
                   params=_params)
        _params['keys'] = keys
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ModelSequencesResult)
    async def Sequences(self):
        '''

        Returns -> ModelSequencesResult
        '''

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ModelConfig',
                   request='Sequences',
                   version=4,
                   params=_params)

        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(None)
    async def SetModelConstraints(self, application=None, constraints=None):
        '''

        application : str
        constraints : Value
        Returns -> None
        '''
        if application is not None and not isinstance(application, (bytes, str)):
            raise Exception("Expected application to be a str, received: {}".format(type(application)))

        if constraints is not None and not isinstance(constraints, (dict, Value)):
            raise Exception("Expected constraints to be a Value, received: {}".format(type(constraints)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ModelConfig',
                   request='SetModelConstraints',
                   version=4,
                   params=_params)
        _params['application'] = application
        _params['constraints'] = constraints
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResult)
    async def SetModelSecretBackend(self, secret_backend_name=None):
        '''

        secret_backend_name : str
        Returns -> ErrorResult
        '''
        if secret_backend_name is not None and not isinstance(secret_backend_name, (bytes, str)):
            raise Exception("Expected secret_backend_name to be a str, received: {}".format(type(secret_backend_name)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ModelConfig',
                   request='SetModelSecretBackend',
                   version=4,
                   params=_params)
        _params['secret-backend-name'] = secret_backend_name
        reply = await self.rpc(msg)
        return reply


