# DO NOT CHANGE THIS FILE! This file is auto-generated by facade.py.
# Changes will be overwritten/lost when the file is regenerated.

from juju.client.facade import Type, ReturnMapping
from juju.client._definitions import *


class BundleFacade(Type):
    name = 'Bundle'
    version = 8
    

    @ReturnMapping(StringResult)
    async def ExportBundle(self, include_charm_defaults=None):
        '''

        include_charm_defaults : bool
        Returns -> StringResult
        '''
        if include_charm_defaults is not None and not isinstance(include_charm_defaults, bool):
            raise Exception("Expected include_charm_defaults to be a bool, received: {}".format(type(include_charm_defaults)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Bundle',
                   request='ExportBundle',
                   version=8,
                   params=_params)
        _params['include-charm-defaults'] = include_charm_defaults
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(BundleChangesMapArgsResults)
    async def GetChangesMapArgs(self, bundleurl=None, yaml=None):
        '''

        bundleurl : str
        yaml : str
        Returns -> BundleChangesMapArgsResults
        '''
        if bundleurl is not None and not isinstance(bundleurl, (bytes, str)):
            raise Exception("Expected bundleurl to be a str, received: {}".format(type(bundleurl)))

        if yaml is not None and not isinstance(yaml, (bytes, str)):
            raise Exception("Expected yaml to be a str, received: {}".format(type(yaml)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Bundle',
                   request='GetChangesMapArgs',
                   version=8,
                   params=_params)
        _params['bundleURL'] = bundleurl
        _params['yaml'] = yaml
        reply = await self.rpc(msg)
        return reply



class ClientFacade(Type):
    name = 'Client'
    version = 8
    

    @ReturnMapping(FullStatus)
    async def FullStatus(self, include_storage=None, patterns=None):
        '''

        include_storage : bool
        patterns : typing.Sequence[str]
        Returns -> FullStatus
        '''
        if include_storage is not None and not isinstance(include_storage, bool):
            raise Exception("Expected include_storage to be a bool, received: {}".format(type(include_storage)))

        if patterns is not None and not isinstance(patterns, (bytes, str, list)):
            raise Exception("Expected patterns to be a Sequence, received: {}".format(type(patterns)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Client',
                   request='FullStatus',
                   version=8,
                   params=_params)
        _params['include-storage'] = include_storage
        _params['patterns'] = patterns
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(StatusHistoryResults)
    async def StatusHistory(self, requests=None):
        '''

        requests : typing.Sequence[~StatusHistoryRequest]
        Returns -> StatusHistoryResults
        '''
        if requests is not None and not isinstance(requests, (bytes, str, list)):
            raise Exception("Expected requests to be a Sequence, received: {}".format(type(requests)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Client',
                   request='StatusHistory',
                   version=8,
                   params=_params)
        _params['requests'] = requests
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(AllWatcherId)
    async def WatchAll(self):
        '''

        Returns -> AllWatcherId
        '''

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Client',
                   request='WatchAll',
                   version=8,
                   params=_params)

        reply = await self.rpc(msg)
        return reply


