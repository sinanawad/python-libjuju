# DO NOT CHANGE THIS FILE! This file is auto-generated by facade.py.
# Changes will be overwritten/lost when the file is regenerated.

from juju.client.facade import Type, ReturnMapping
from juju.client._definitions import *


class CredentialManagerFacade(Type):
    name = 'CredentialManager'
    version = 1
    

class ImageMetadataManagerFacade(Type):
    name = 'ImageMetadataManager'
    version = 1
    

    @ReturnMapping(ErrorResults)
    async def Delete(self, image_ids=None):
        '''

        image_ids : typing.Sequence[str]
        Returns -> ErrorResults
        '''
        if image_ids is not None and not isinstance(image_ids, (bytes, str, list)):
            raise Exception("Expected image_ids to be a Sequence, received: {}".format(type(image_ids)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ImageMetadataManager',
                   request='Delete',
                   version=1,
                   params=_params)
        _params['image-ids'] = image_ids
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ListCloudImageMetadataResult)
    async def List(self, arches=None, region=None, root_storage_type=None, stream=None, versions=None, virt_type=None):
        '''

        arches : typing.Sequence[str]
        region : str
        root_storage_type : str
        stream : str
        versions : typing.Sequence[str]
        virt_type : str
        Returns -> ListCloudImageMetadataResult
        '''
        if arches is not None and not isinstance(arches, (bytes, str, list)):
            raise Exception("Expected arches to be a Sequence, received: {}".format(type(arches)))

        if region is not None and not isinstance(region, (bytes, str)):
            raise Exception("Expected region to be a str, received: {}".format(type(region)))

        if root_storage_type is not None and not isinstance(root_storage_type, (bytes, str)):
            raise Exception("Expected root_storage_type to be a str, received: {}".format(type(root_storage_type)))

        if stream is not None and not isinstance(stream, (bytes, str)):
            raise Exception("Expected stream to be a str, received: {}".format(type(stream)))

        if versions is not None and not isinstance(versions, (bytes, str, list)):
            raise Exception("Expected versions to be a Sequence, received: {}".format(type(versions)))

        if virt_type is not None and not isinstance(virt_type, (bytes, str)):
            raise Exception("Expected virt_type to be a str, received: {}".format(type(virt_type)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ImageMetadataManager',
                   request='List',
                   version=1,
                   params=_params)
        _params['arches'] = arches
        _params['region'] = region
        _params['root-storage-type'] = root_storage_type
        _params['stream'] = stream
        _params['versions'] = versions
        _params['virt-type'] = virt_type
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def Save(self, metadata=None):
        '''

        metadata : typing.Sequence[~CloudImageMetadataList]
        Returns -> ErrorResults
        '''
        if metadata is not None and not isinstance(metadata, (bytes, str, list)):
            raise Exception("Expected metadata to be a Sequence, received: {}".format(type(metadata)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ImageMetadataManager',
                   request='Save',
                   version=1,
                   params=_params)
        _params['metadata'] = metadata
        reply = await self.rpc(msg)
        return reply



class KeyManagerFacade(Type):
    name = 'KeyManager'
    version = 1
    

    @ReturnMapping(ErrorResults)
    async def AddKeys(self, ssh_keys=None, user=None):
        '''

        ssh_keys : typing.Sequence[str]
        user : str
        Returns -> ErrorResults
        '''
        if ssh_keys is not None and not isinstance(ssh_keys, (bytes, str, list)):
            raise Exception("Expected ssh_keys to be a Sequence, received: {}".format(type(ssh_keys)))

        if user is not None and not isinstance(user, (bytes, str)):
            raise Exception("Expected user to be a str, received: {}".format(type(user)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='KeyManager',
                   request='AddKeys',
                   version=1,
                   params=_params)
        _params['ssh-keys'] = ssh_keys
        _params['user'] = user
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def DeleteKeys(self, ssh_keys=None, user=None):
        '''

        ssh_keys : typing.Sequence[str]
        user : str
        Returns -> ErrorResults
        '''
        if ssh_keys is not None and not isinstance(ssh_keys, (bytes, str, list)):
            raise Exception("Expected ssh_keys to be a Sequence, received: {}".format(type(ssh_keys)))

        if user is not None and not isinstance(user, (bytes, str)):
            raise Exception("Expected user to be a str, received: {}".format(type(user)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='KeyManager',
                   request='DeleteKeys',
                   version=1,
                   params=_params)
        _params['ssh-keys'] = ssh_keys
        _params['user'] = user
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def ImportKeys(self, ssh_keys=None, user=None):
        '''

        ssh_keys : typing.Sequence[str]
        user : str
        Returns -> ErrorResults
        '''
        if ssh_keys is not None and not isinstance(ssh_keys, (bytes, str, list)):
            raise Exception("Expected ssh_keys to be a Sequence, received: {}".format(type(ssh_keys)))

        if user is not None and not isinstance(user, (bytes, str)):
            raise Exception("Expected user to be a str, received: {}".format(type(user)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='KeyManager',
                   request='ImportKeys',
                   version=1,
                   params=_params)
        _params['ssh-keys'] = ssh_keys
        _params['user'] = user
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(StringsResults)
    async def ListKeys(self, entities=None, mode=None):
        '''

        entities : Entities
        mode : bool
        Returns -> StringsResults
        '''
        if entities is not None and not isinstance(entities, (dict, Entities)):
            raise Exception("Expected entities to be a Entities, received: {}".format(type(entities)))

        if mode is not None and not isinstance(mode, bool):
            raise Exception("Expected mode to be a bool, received: {}".format(type(mode)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='KeyManager',
                   request='ListKeys',
                   version=1,
                   params=_params)
        _params['entities'] = entities
        _params['mode'] = mode
        reply = await self.rpc(msg)
        return reply



class ModelUpgraderFacade(Type):
    name = 'ModelUpgrader'
    version = 1
    

    @ReturnMapping(None)
    async def AbortModelUpgrade(self, model_tag=None):
        '''

        model_tag : str
        Returns -> None
        '''
        if model_tag is not None and not isinstance(model_tag, (bytes, str)):
            raise Exception("Expected model_tag to be a str, received: {}".format(type(model_tag)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ModelUpgrader',
                   request='AbortModelUpgrade',
                   version=1,
                   params=_params)
        _params['model-tag'] = model_tag
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(UpgradeModelResult)
    async def UpgradeModel(self, agent_stream=None, dry_run=None, ignore_agent_versions=None, model_tag=None, target_version=None):
        '''

        agent_stream : str
        dry_run : bool
        ignore_agent_versions : bool
        model_tag : str
        target_version : Number
        Returns -> UpgradeModelResult
        '''
        if agent_stream is not None and not isinstance(agent_stream, (bytes, str)):
            raise Exception("Expected agent_stream to be a str, received: {}".format(type(agent_stream)))

        if dry_run is not None and not isinstance(dry_run, bool):
            raise Exception("Expected dry_run to be a bool, received: {}".format(type(dry_run)))

        if ignore_agent_versions is not None and not isinstance(ignore_agent_versions, bool):
            raise Exception("Expected ignore_agent_versions to be a bool, received: {}".format(type(ignore_agent_versions)))

        if model_tag is not None and not isinstance(model_tag, (bytes, str)):
            raise Exception("Expected model_tag to be a str, received: {}".format(type(model_tag)))

        if target_version is not None and not isinstance(target_version, (dict, Number)):
            raise Exception("Expected target_version to be a Number, received: {}".format(type(target_version)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='ModelUpgrader',
                   request='UpgradeModel',
                   version=1,
                   params=_params)
        _params['agent-stream'] = agent_stream
        _params['dry-run'] = dry_run
        _params['ignore-agent-versions'] = ignore_agent_versions
        _params['model-tag'] = model_tag
        _params['target-version'] = target_version
        reply = await self.rpc(msg)
        return reply



class PingerFacade(Type):
    name = 'Pinger'
    version = 1
    

    @ReturnMapping(None)
    async def Ping(self):
        '''

        Returns -> None
        '''

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Pinger',
                   request='Ping',
                   version=1,
                   params=_params)

        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(None)
    async def Stop(self):
        '''

        Returns -> None
        '''

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='Pinger',
                   request='Stop',
                   version=1,
                   params=_params)

        reply = await self.rpc(msg)
        return reply



class SecretBackendsFacade(Type):
    name = 'SecretBackends'
    version = 1
    

    @ReturnMapping(ErrorResults)
    async def AddSecretBackends(self, args=None):
        '''

        args : typing.Sequence[~AddSecretBackendArg]
        Returns -> ErrorResults
        '''
        if args is not None and not isinstance(args, (bytes, str, list)):
            raise Exception("Expected args to be a Sequence, received: {}".format(type(args)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='SecretBackends',
                   request='AddSecretBackends',
                   version=1,
                   params=_params)
        _params['args'] = args
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ListSecretBackendsResults)
    async def ListSecretBackends(self, names=None, reveal=None):
        '''

        names : typing.Sequence[str]
        reveal : bool
        Returns -> ListSecretBackendsResults
        '''
        if names is not None and not isinstance(names, (bytes, str, list)):
            raise Exception("Expected names to be a Sequence, received: {}".format(type(names)))

        if reveal is not None and not isinstance(reveal, bool):
            raise Exception("Expected reveal to be a bool, received: {}".format(type(reveal)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='SecretBackends',
                   request='ListSecretBackends',
                   version=1,
                   params=_params)
        _params['names'] = names
        _params['reveal'] = reveal
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def RemoveSecretBackends(self, args=None):
        '''

        args : typing.Sequence[~RemoveSecretBackendArg]
        Returns -> ErrorResults
        '''
        if args is not None and not isinstance(args, (bytes, str, list)):
            raise Exception("Expected args to be a Sequence, received: {}".format(type(args)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='SecretBackends',
                   request='RemoveSecretBackends',
                   version=1,
                   params=_params)
        _params['args'] = args
        reply = await self.rpc(msg)
        return reply



    @ReturnMapping(ErrorResults)
    async def UpdateSecretBackends(self, args=None):
        '''

        args : typing.Sequence[~UpdateSecretBackendArg]
        Returns -> ErrorResults
        '''
        if args is not None and not isinstance(args, (bytes, str, list)):
            raise Exception("Expected args to be a Sequence, received: {}".format(type(args)))

        # map input types to rpc msg
        _params = dict()
        msg = dict(type='SecretBackends',
                   request='UpdateSecretBackends',
                   version=1,
                   params=_params)
        _params['args'] = args
        reply = await self.rpc(msg)
        return reply


